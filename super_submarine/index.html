<html>

	<head>
		<title>super submarine!</title>
		
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js'></script>
		<script src='GLTFLoader.js'></script>
		<script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
		<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js" integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=" crossorigin="anonymous"></script>
		<script src="threex.keyboardstate.js"></script>
	
	</head>
	
	<style>
		canvas{
			border: 1px solid #000;
		}
		#container{
			width: 1200px;
			height: 800px;
		}
	</style>
	
	<body>
		<div id='container'>
		</div>
	</body>

	<script type="module">
	//import { Water } from '/node_modules/three/examples/jsm/objects/Water.js';
	// https://forums.ogre3d.org/viewtopic.php?t=47645
	let rotation = 0;
	
	// https://stemkoski.github.io/Three.js/Shader-Animate.html
	var waterShader = {
	
		vertexShader: [
			'varying vec2 vUv;',
			'void main(){',
			'   vUv = uv;',
			'   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );}'
		].join('\n'),
		
		fragmentShader: [
			'uniform sampler2D baseTexture;',
			'uniform float baseSpeed;',
			'uniform sampler2D noiseTexture;',
			'uniform float noiseScale;',
			'uniform float alpha;',
			'uniform float time;',
			'varying vec2 vUv;',
			'void main() {',
			'	vec2 uvTimeShift = vUv + vec2( -0.7, 1.2 ) * time * baseSpeed;'	,
			'	vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );',
			'	vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b );',
			'	vec4 baseColor = texture2D( baseTexture, uvNoiseTimeShift );',
			'	baseColor.a = alpha;',
			'	gl_FragColor = baseColor;}',
		].join('\n')
	}

	// https://github.com/evanw/webgl-water
	// https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js
	var el = document.getElementById("container");
    const fov = 60;
    const defaultCamera = new THREE.PerspectiveCamera(fov, el.clientWidth / el.clientHeight, 0.01, 1000);
	var keyboard = new THREEx.KeyboardState();
	const container = document.querySelector('#container');
	const renderer = new THREE.WebGLRenderer();
	renderer.shadowMap.enabled = true;
	renderer.setSize(el.clientWidth, el.clientHeight);	
	container.appendChild(renderer.domElement);
	
	const camera = defaultCamera;
	camera.position.set(0,2,0);
	
	const scene = new THREE.Scene();
	scene.background = new THREE.Color(0xffffff);	
	scene.add(camera);

	let loader = new THREE.GLTFLoader();
	let pointLight = new THREE.PointLight(0xffffff, 1, 0); //new THREE.pointLight( 0xffffff );
	pointLight.position.set(0, 10, -35);
	pointLight.castShadow = true;
	pointLight.shadow.mapSize.width = 512;
	pointLight.shadow.mapSize.height = 512;
	pointLight.shadow.camera.near = 10;
	pointLight.shadow.camera.far = 100;
	pointLight.shadow.camera.fov = 30;
	scene.add(pointLight);
	
	const clock = new THREE.Clock();
	var sec = clock.getDelta();
	var moveDistance = 60 * sec;
	var rotationAngle = (Math.PI / 2) * sec;
	
	let loadedModels = [];

	function getModel(modelFilePath, side, name){
		return new Promise((resolve, reject) => {
			loader.load(
				modelFilePath,
				function(gltf){
					gltf.scene.traverse((child) => {
						if(child.type === "Mesh"){
						
							let material = child.material;
							let geometry = child.geometry;
							let obj = new THREE.Mesh(geometry, material);
							
							obj.scale.x = child.scale.x * 20;
							obj.scale.y = child.scale.y * 20;
							obj.scale.z = child.scale.z * 20;
							obj.rotateOnAxis(new THREE.Vector3(0,1,0), Math.PI / 2);
						
							obj.side = side; // player or enemy mesh?
							obj.name = name;
							resolve(obj);
						}
					});
				},
				// called while loading is progressing
				function(xhr){
					console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
				},
				// called when loading has errors
				function(error){
					console.log('An error happened');
					console.log(error);
				}
			);
		});
	}
	
	var newSphere = createSphereWireframe({}, {});
	scene.add(newSphere);
	var newSphere2 = createSphereWireframe({x: 5, y: 6, z: -45}, {});
	scene.add(newSphere2);

	// https://threejs.org/docs/#api/en/textures/Texture
	// create a mesh, apply ocean shader on it 
	loadedModels.push(getModel('old battleship models/submarine1.glb', 'player', 'p1'));
	loadedModels.push(getModel('old battleship models/battleship2.glb', 'player2', 'p2'));
	let thePlayer = null;
	Promise.all(loadedModels).then((objects) => {
		objects.forEach((mesh) => {
			if(mesh.name === "p2"){
				mesh.position.set(-15, 8, -50);
			}else{
				// the local axis of the imported mesh is a bit weird and not consistent with the world axis. so, to fix that,
				// put it in a group object and just control the group object! the mesh is also just orientated properly initially when placed in the group.
				// https://stackoverflow.com/questions/59446956/how-can-i-change-the-position-of-an-imported-model-in-three-js
				var group = new THREE.Group();
				group.add(mesh);
				thePlayer = group;
				mesh = group;
				mesh.position.set(0, 0, -10);
				
				animate();
			}
			
			mesh.castShadow = true;
			mesh.receiveShadow = true;
			scene.add(mesh);
			renderer.render(scene, camera);
		})
	});
	
	function createSphereWireframe(position, params){
		var geometry = new THREE.SphereGeometry(4, 8, 6, 0, 6.3, 0, 3.1);
		var material = new THREE.MeshBasicMaterial({color: 0x3333ff});
		var sphere = new THREE.LineSegments(new THREE.WireframeGeometry(geometry)); // new THREE.Mesh(geometry, material)
		var x = position.x || 0;
		var y = position.y || 8;
		var z = position.z || -25;
		sphere.position.set(x, y, z);
		return sphere;
	}
	
	//https://stackoverflow.com/questions/38305408/threejs-get-center-of-object
	function getCenter(mesh){
		var mid = new THREE.Vector3();
		var geometry = mesh.geometry;
		
		geometry.computeBoundingBox();
		mid.x = (geometry.boundingBox.max.x + geometry.boundingBox.min.x)/2;
		mid.y = (geometry.boundingBox.max.y + geometry.boundingBox.min.y)/2;
		mid.z = (geometry.boundingBox.max.z + geometry.boundingBox.min.z)/2;
		
		mesh.localToWorld(mid);
		return mid;
	}
	
	function getForward(mesh){
		var forwardVec = new THREE.Vector3();
		mesh.getWorldDirection(forwardVec);	
		return forwardVec;
	}
	
	function drawForwardVector(mesh){
		var forwardVec = new THREE.Vector3();
		forwardVec.applyQuaternion(mesh.quaternion);
		
		// create a vector 
		var point1 = getCenter(mesh); //new THREE.Vector3(forwardVec.x, forwardVec.y, forwardVec.z);
		var point2 = new THREE.Vector3(forwardVec.x, forwardVec.y, forwardVec.z); 
		point2.multiplyScalar(2);
		
		var points = [point1, point2];
		
		var material = new THREE.LineBasicMaterial({color: 0x0000ff});
		var geometry = new THREE.BufferGeometry().setFromPoints(points);
		var line = new THREE.Line(geometry, material);
		scene.add(line);
	}

	function update(){
		// https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/Chase-Camera.html
		// http://stemkoski.github.io/Three.js/Chase-Camera.html
		sec = clock.getDelta();
		moveDistance = 20 * sec;
		rotationAngle = (Math.PI / 2) * sec;
		
		if(keyboard.pressed("W")){
			thePlayer.translateZ(-moveDistance);
		}
		
		if(keyboard.pressed("S")){
			thePlayer.translateZ(moveDistance);
		}
		
		if(keyboard.pressed("A")){
			// rotate the sub and the camera appropriately
			var axis = new THREE.Vector3(0, 1, 0);
			thePlayer.rotateOnAxis(axis, rotationAngle);
		}
		
		if(keyboard.pressed("D")){
			var axis = new THREE.Vector3(0, 1, 0);
			thePlayer.rotateOnAxis(axis, -rotationAngle);
		}
		
		if(keyboard.pressed("Q")){
			var axis = new THREE.Vector3(0, 0, 1);
			thePlayer.rotateOnAxis(axis, rotationAngle);
		}
		
		if(keyboard.pressed("E")){
			var axis = new THREE.Vector3(0, 0, 1);
			thePlayer.rotateOnAxis(axis, -rotationAngle);
		}
		
		if(keyboard.pressed("up")){
			// rotate up (note that we're rotating on the mesh's axis. its axes might be configured weird)
			// the forward vector for the mesh might be backwards and perpendicular to the front of the sub
			// up arrow key
			// NEED TO CLAMP ANGLE
			var axis = new THREE.Vector3(1, 0, 0);
			thePlayer.rotateOnAxis(axis, rotationAngle);
		}
		
		if(keyboard.pressed("down")){
			// down arrow key
			// CLAMP ANGLE!
			var axis = new THREE.Vector3(1, 0, 0);
			thePlayer.rotateOnAxis(axis, -rotationAngle);
		}
		
		// setting offset to THREE.Vector3(0, 5, 5) looks good for 1st person view :D
		var relCameraOffset = new THREE.Vector3(0, 3, 12);
		var cameraOffset = relCameraOffset.applyMatrix4(thePlayer.matrixWorld);
		camera.position.x = cameraOffset.x;
		camera.position.y = cameraOffset.y;
		camera.position.z = cameraOffset.z;
		camera.lookAt(thePlayer.position);
	}
	
	function animate(){
		requestAnimationFrame(animate);
		renderer.render(scene, camera);
		update();
	}

	</script>

</html>