<html>

	<head>
		<title>super submarine!</title>
		
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js'></script>
		<script src='GLTFLoader.js'></script>
		<script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
		<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js" integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=" crossorigin="anonymous"></script>
	
	</head>
	
	<style>
		canvas{
			border: 1px solid #000;
		}
		#container {
			width: 800px;
			height: 800px;
		}
	</style>
	
	<body>
		<div id='container'>
		</div>
	</body>

	<script type="module">
	//import { Water } from '/node_modules/three/examples/jsm/objects/Water.js';
	// https://forums.ogre3d.org/viewtopic.php?t=47645
	let rotation = 0;
	
	// https://stemkoski.github.io/Three.js/Shader-Animate.html
	var waterShader = {
	
		vertexShader: [
			'varying vec2 vUv;',
			'void main(){',
			'   vUv = uv;',
			'   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );}'
		].join('\n'),
		
		fragmentShader: [
			'uniform sampler2D baseTexture;',
			'uniform float baseSpeed;',
			'uniform sampler2D noiseTexture;',
			'uniform float noiseScale;',
			'uniform float alpha;',
			'uniform float time;',
			'varying vec2 vUv;',
			'void main() {',
			'	vec2 uvTimeShift = vUv + vec2( -0.7, 1.2 ) * time * baseSpeed;'	,
			'	vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );',
			'	vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b );',
			'	vec4 baseColor = texture2D( baseTexture, uvNoiseTimeShift );',
			'	baseColor.a = alpha;',
			'	gl_FragColor = baseColor;}',
		].join('\n')
	}

	// https://github.com/evanw/webgl-water
	// https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js
	var el = document.getElementById("container");
    const fov = 60;
    const defaultCamera = new THREE.PerspectiveCamera(fov, el.clientWidth / el.clientHeight, 0.01, 1000);
	
	const container = document.querySelector('#container');
	const renderer = new THREE.WebGLRenderer();
	renderer.shadowMap.enabled = true;
	
	const camera = defaultCamera;
	camera.position.set(0,2,0);
	
	const scene = new THREE.Scene();
	scene.background = new THREE.Color(0xffffff);	
	scene.add(camera);

	let loader = new THREE.GLTFLoader();
	let spotLight = new THREE.PointLight(0xffffff, 1, 100); //new THREE.SpotLight( 0xffffff );
	spotLight.position.set(0, 5, -25);

	spotLight.castShadow = true;
	spotLight.shadow.mapSize.width = 512;
	spotLight.shadow.mapSize.height = 512;
	spotLight.shadow.camera.near = 10;
	spotLight.shadow.camera.far = 100;
	spotLight.shadow.camera.fov = 30;

	scene.add(spotLight);
	
	let loadedModels = [];
		
	let raycaster = new THREE.Raycaster();
	let mouse = new THREE.Vector2(-1, -1);

	function getModel(modelFilePath, side, name){
		return new Promise((resolve, reject) => {
			loader.load(
				modelFilePath,
				function(gltf){
					gltf.scene.traverse((child) => {
						if(child.type === "Mesh"){
						
							let material = child.material;
							let geometry = child.geometry;
							let obj = new THREE.Mesh(geometry, material);
							
							obj.scale.x = child.scale.x * 20;
							obj.scale.y = child.scale.y * 20;
							obj.scale.z = child.scale.z * 20;
							obj.rotateOnAxis(new THREE.Vector3(0,1,0), Math.PI / 2); // note this on object's local axis! so when you rotate, the axes change (i.e. x becomes z)
							//obj.rotateOnAxis(new THREE.Vector3(0,0,1), Math.PI / 2);
						
							obj.side = side; // player or enemy mesh?
							obj.name = name;
							resolve(obj);
						}
					});
				},
				// called while loading is progressing
				function(xhr){
					console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
				},
				// called when loading has errors
				function(error){
					console.log( 'An error happened' );
					console.log(error);
				}
			);
		});
	}
	
	var newSphere = createSphereWireframe({}, {});
	scene.add(newSphere);
	var newSphere2 = createSphereWireframe({x: 5, y: 6, z: -45}, {});
	scene.add(newSphere2);

	// https://threejs.org/docs/#api/en/textures/Texture
	// create a mesh, apply ocean shader on it 
	loadedModels.push(getModel('old battleship models/submarine1.glb', 'player', 'p1'));
	loadedModels.push(getModel('old battleship models/battleship2.glb', 'player2', 'p2'));
	let theMesh = null;
	Promise.all(loadedModels).then((objects) => {
		objects.forEach((mesh) => {
			if(mesh.name === "p2"){
				mesh.position.set(-15, 8, -50);
			}else{
				// the local axis of the imported mesh is a bit weird and not consistent with the world axis. so, to fix that,
				// put it in a group object and just control the group object! the mesh is also just orientated properly initially when placed in the group.
				// https://stackoverflow.com/questions/59446956/how-can-i-change-the-position-of-an-imported-model-in-three-js
				var group = new THREE.Group();
				group.add(mesh);
				theMesh = group; //mesh;
				mesh = group;
				mesh.position.set(0, 0, -10);
			}
			
			mesh.castShadow = true;
			mesh.receiveShadow = true;
			scene.add(mesh);
			renderer.render(scene, camera);
		})
	});
	
	function createSphereWireframe(position, params){
		var geometry = new THREE.SphereGeometry(4, 8, 6, 0, 6.3, 0, 3.1);
		var material = new THREE.MeshBasicMaterial({color: 0x3333ff});
		var sphere = new THREE.LineSegments(new THREE.WireframeGeometry(geometry)); // new THREE.Mesh(geometry, material)
		var x = position.x || 0;
		var y = position.y || 8;
		var z = position.z || -25;
		sphere.position.set(x, y, z);
		return sphere;
	}
	
	renderer.setSize(el.clientWidth, el.clientHeight);	
	container.appendChild(renderer.domElement);
	

	var clock = new THREE.Clock();
	
	function animate(){
		requestAnimationFrame(animate);
		renderer.render(scene, camera);
		update();
	}
	
	//https://stackoverflow.com/questions/38305408/threejs-get-center-of-object
	function getCenter(mesh){
		var mid = new THREE.Vector3();
		var geometry = mesh.geometry;
		
		geometry.computeBoundingBox();
		mid.x = (geometry.boundingBox.max.x + geometry.boundingBox.min.x)/2;
		mid.y = (geometry.boundingBox.max.y + geometry.boundingBox.min.y)/2;
		mid.z = (geometry.boundingBox.max.z + geometry.boundingBox.min.z)/2;
		
		mesh.localToWorld(mid);
		return mid;
	}
	
	function drawForwardVector(mesh){
		var forwardVec = new THREE.Vector3();
		//mesh.getWorldDirection(forwardVec);
		forwardVec.applyQuaternion(theMesh.quaternion);
		
		
		// create a vector 
		var point1 = getCenter(mesh); //new THREE.Vector3(forwardVec.x, forwardVec.y, forwardVec.z);
		var point2 = new THREE.Vector3(forwardVec.x, forwardVec.y, forwardVec.z); 
		point2.multiplyScalar(2);
		//console.log(point1);
		//onsole.log(point2);
		
		var points = [point1, point2];
		
		var material = new THREE.LineBasicMaterial({color: 0x0000ff});
		var geometry = new THREE.BufferGeometry().setFromPoints(points);
		var line = new THREE.Line(geometry, material);
		scene.add(line);
		//renderer.render(scene, camera);
	}


	function update(){
		// https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/Chase-Camera.html
		// http://stemkoski.github.io/Three.js/Chase-Camera.html
		var sec = clock.getDelta();
		var moveDistance = 0.25 * sec;
		var rotationAngle = (Math.PI / 2) * sec;
		
		window.addEventListener('keydown', event => {
			if(event.keyCode === 87){
				// w key press
				theMesh.translateZ(-moveDistance);
				camera.translateZ(-moveDistance);
				
			}else if(event.keyCode === 83){
				// go backwards (S)
				theMesh.translateZ(moveDistance);
				camera.translateZ(moveDistance);
				
			}else if(event.keyCode === 65){
				// go left (A)
				// NEED TO CLAMP ANGLE
				// rotate the sub and the camera appropriately
				var axis = new THREE.Vector3(0, 1, 0);
				theMesh.rotateOnAxis(axis, rotationAngle/100);
				camera.rotateOnAxis(axis, rotationAngle/100);
				
				// then translate the camera so it stays behind the sub
				var forwardVec = new THREE.Vector3();
				theMesh.getWorldDirection(forwardVec);

				var newPos = new THREE.Vector3(forwardVec.x, forwardVec.y, forwardVec.z);
				camera.position.x = theMesh.position.x + (newPos.x * 10);
				camera.position.z = theMesh.position.z + (newPos.z * 10);

			}else if(event.keyCode === 68){
				// go right (D)
				// NEED TO CLAMP ANGLE
				var axis = new THREE.Vector3(0, 1, 0);
				theMesh.rotateOnAxis(axis, -rotationAngle/100);
				camera.rotateOnAxis(axis, -rotationAngle/100);
				
				// then translate the camera so it stays behind the sub
				var forwardVec = new THREE.Vector3();
				theMesh.getWorldDirection(forwardVec);

				var newPos = new THREE.Vector3(forwardVec.x, forwardVec.y, forwardVec.z);
				camera.position.x = theMesh.position.x + (newPos.x * 10);
				camera.position.z = theMesh.position.z + (newPos.z * 10);

			}else if(event.keyCode === 81){
				// rotate left (Q)
				var axis = new THREE.Vector3(0, 0, 1);
				theMesh.rotateOnAxis(axis, rotationAngle/100);
				camera.rotateOnAxis(axis, rotationAngle/100);
				
				// then translate the camera so it stays behind the sub
				var forwardVec = new THREE.Vector3();
				theMesh.getWorldDirection(forwardVec);						
				var newPos = new THREE.Vector3(forwardVec.x, forwardVec.y, forwardVec.z);
				
				camera.position.z = theMesh.position.z + (newPos.z * 10);

			}else if(event.keyCode === 69){
				// rotate right (E)
				var axis = new THREE.Vector3(0, 0, 1);
				theMesh.rotateOnAxis(axis, -rotationAngle/100);
				camera.rotateOnAxis(axis, -rotationAngle/100); // camera axis is not the same as the object here! x and z have been swapped?
				
				var forwardVec = new THREE.Vector3();
				theMesh.getWorldDirection(forwardVec);						
				var newPos = new THREE.Vector3(forwardVec.x, forwardVec.y, forwardVec.z);
				
				camera.position.z = theMesh.position.z + (newPos.z * 10);
				
			}else if(event.keyCode === 38){
				// rotate up (note that we're rotating on the mesh's axis. its axes might be configured weird)
				// the forward vector for the mesh might be backwards and perpendicular to the front of the sub
				// up arrow key
				// NEED TO CLAMP ANGLE
				var axis = new THREE.Vector3(1, 0, 0);
				theMesh.rotateOnAxis(axis, rotationAngle/100);	
				camera.rotateOnAxis(axis, rotationAngle/100); // camera axis is not the same as the object here! x and z have been swapped?

				var forwardVec = new THREE.Vector3();
				theMesh.getWorldDirection(forwardVec);						
				var newPos = new THREE.Vector3(forwardVec.x, forwardVec.y, forwardVec.z);
				
				newPos.multiplyScalar(5);
				camera.position.x = newPos.x;
				camera.position.y = newPos.y;
				camera.position.z = newPos.z;

			}else if(event.keyCode === 40){
				// down arrow key
				// CLAMP ANGLE!
				var axis = new THREE.Vector3(1, 0, 0);
				theMesh.rotateOnAxis(axis, -rotationAngle/100);	
				camera.rotateOnAxis(axis, -rotationAngle/100); // camera axis is not the same as the object here! x and z have been swapped?
				
				var forwardVec = new THREE.Vector3();
				theMesh.getWorldDirection(forwardVec);						
				var newPos = new THREE.Vector3(forwardVec.x, forwardVec.y, forwardVec.z);
				
				newPos.multiplyScalar(5);
				camera.position.x = newPos.x;
				camera.position.y = newPos.y;
				camera.position.z = newPos.z;
			}
			
		});
	}
	
	animate();

	</script>

</html>